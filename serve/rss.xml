<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>ZengHui Bao's blog</title>
        <description>ZengHui Bao's blog - </description>
        <link>/rss.xml</link>
        <link></link>
        <lastBuildDate>2015-11-22T21:42:04+08:00</lastBuildDate>
        <pubDate>2015-11-22T21:42:04+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>实现了一个小型的容器库</title>
                <description>&lt;p&gt;最近两个月花时间实现了一个小型的容器库(&lt;a href=&quot;https://github.com/baozh/container&quot;&gt;Github地址&lt;/a&gt;，以下简称Minimal Container)，实现了C++中的dynamic array,list,queue,map,hashmap,set,hashset等基本的容器，它是一个非正式的、业余的作品，做这个小项目主要是想积累一下写库的经验。这篇文章记录一下我编程时遇到的问题、及每个容器的实现思路。&lt;/p&gt;

&lt;!--more--&gt;


&lt;h3&gt;思考&lt;/h3&gt;

&lt;p&gt;设计并实现一个好的库不是一件容易的事，需要熟悉业务、积累经验。我在实现Minimal Container时，考虑以下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如何做封装：隐藏内部变量，隔离变化，适应变化。&lt;/li&gt;
&lt;li&gt;如何做抽象：从各种不同的类型、方法、环境中抽象出一致的方法。&lt;/li&gt;
&lt;li&gt;如何设计接口：从易用、一致性、灵活性方面考虑。&lt;/li&gt;
&lt;li&gt;如何实现复杂一些的数据结构(如hashtable,red-black tree)。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;其实对标准容器库来说，抽象、设计接口并不是难事，因为它的功能不复杂，业内的开源代码、教科书上都已经有总结了。我觉得难点在于如何抽象出一致性，并设计一个简单易用、一致性的接口。比如STL中每个容器中都有empty(),insert(),erase(),find()，并对每个容器的访问抽象了一层，实现的容器的迭代器，使得算法和容器的实现能够分离，也使得接口易于使用。&lt;/p&gt;

&lt;p&gt;实现一个业务库可能更难一些，因为它没有范例参考，只能根据开发者的经验来抽象出接口。今年在维护一个内部的告警主机项目(alarmpu)时，我对抽象、设计有了更直接、深刻的理解。alarmpu中采用了插件式设计，将其中类似的一组功能(如初始化告警源、什么时候初始好、什么时候产生告警信号)抽象成了一组函数(通知采用回调函数)，这些函数组成了一个插件(其实就是一个动态链接库DLL)，项目主体只调用DLL一些来完成一些简单的逻辑处理(如程序启用时调用dll来连接到告警源，收到告警信息时将信号转发给平台)，这使得软件很容易扩展，也会隔离变化。要扩展一个新的告警源实现告警联动时，只需实现DLL的一些接口函数即可。实现这些接口不难，难的是从实践中抽象总结出这些接口，这个需要业务经验的积累。&lt;/p&gt;

&lt;h3&gt;实现&lt;/h3&gt;

&lt;p&gt;总体实现的一些特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每个容器都提供一致的容器迭代器，如List::Position,Set::Position,Map::Position，提供一致的向前访问、向后访问接口。&lt;/li&gt;
&lt;li&gt;每个容器都提供一个回调函数，用来遍历操作容器内的所有元素。&lt;/li&gt;
&lt;li&gt;函数名采用一致的命名方法: 谓语+宾语。如MakeEmpty()，而不用Empty()；GetFirstPos()，而不用FirstPos()。&lt;/li&gt;
&lt;li&gt;public函数名均使每个首字母大写来分隔单词（如&lt;code&gt;InsertHead()&lt;/code&gt;），private函数名以&lt;code&gt;__&lt;/code&gt;开头，用&lt;code&gt;_&lt;/code&gt;来分隔单词（如&lt;code&gt;__sort_list()&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;以下按头文件讲述各个容器的实现思路，及编程时遇到的问题。&lt;/p&gt;

&lt;h4&gt;list.h&lt;/h4&gt;

&lt;p&gt;用C++模板实现了双向链表，实现了一些基本的增删改查接口。在实现时遇到了两个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;是否要将链表结点的定义ListNode放到List中？&lt;/p&gt;

&lt;p&gt; 一般来说，总是要将内部使用的类定义放到内部，主要是封装、隔离变化，也可以减少命名冲突。我在第一遍写的时候也是这么做的，但是在编译返回ListNode的函数时报错，因为不能返回private类型的变量。如果将ListNode声明成public也能编译通过，但是代码不太好看、比较拖沓。后来我将ListNode放到了List外部来定义，显得干净清爽多了。如果担心命名冲突，可以在container中定义了命名空间。&lt;/p&gt;

&lt;p&gt; 也许会问为什么要在成员函数中返回ListNode类型的元素？因为要实现迭代器，我在list.h中是重命名了ListNode成Position，而在STL中是将ListNode向上封装了一层iterater，原理是一样的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何实现链表排序？&lt;/p&gt;

&lt;p&gt; 在剖析STL源码时发现STL中实现了链表排序，自己也想试一把。折腾两天，才写出来。在链表中实现快速排序，还是挺麻烦的，具体方法可以参看我的&lt;a href=&quot;http://www.zenghui123.com/2014-10/quicksort-in-list/&quot;&gt;一篇文章&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;darray.h&lt;/h4&gt;

&lt;p&gt;用C++模板实现了动态数组，实现了一些基本的增删改查接口。设计时遇到了一个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数组刚初始化应分配多大空间？什么时候该增加可分配空闲空间的大小，如何增长？当元素删除了很多，要怎么来减少空闲空间的占用？&lt;/p&gt;

&lt;p&gt;  参考了STL及一些开源代码，我的方法是：刚初始化时分配的数组空间为15个，当插入数据导致空间不够时，再分配(m_dwCapacity * 2)多一倍的空间。元素删除时，只做前移不释放空间，只有当使用空间的大小比空闲空间的大小小时，才将总空间减少至使用大小的1.5倍。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;deque.h,queue.h,stack.h&lt;/h4&gt;

&lt;p&gt;用C++模板实现了双向队列，链表，和栈，实现了一些基本的增删改查接口。这三个数据结构都是基于list,darray实现的，方法基本都是调的list,darray的接口。&lt;/p&gt;

&lt;h4&gt;hash_map.h,hash_set.h&lt;/h4&gt;

&lt;p&gt;基于hashtable实现map和set，底层的难点在于如何实现hashtable。hashtable是采用开链法实现，设计时的考虑如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;hash函数的设计。&lt;/p&gt;

&lt;p&gt; hash函数的设计直接关系到map,set性能的好坏及空间的利用率。好的hash函数的特点有两个：1）不要太复杂，计算速度快。2）能够比较均匀得落到分配的各个桶内。参考了一些开源代码，我的hash函数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; inline size_t hash_mysql(const char* key,   size_t len)  
 { 
     if (key == 0)  return 0;

     size_t nr=1, nr2=4; 
     while (len--) 
     { 
         nr^= (((nr &amp;amp; 63)+nr2)*((size_t) (byte) *key++))+ (nr &amp;lt;&amp;lt; 8); 
         nr2+=3; 
     } 
     return((size_t) nr);   
 }

 inline size_t hash_string(const char* pStr, size_t len)
 {
     if (pStr == 0)  return 0;
     size_t nHash = 0;
     while (*pStr)  nHash = (nHash&amp;lt;&amp;lt;5) + nHash + *pStr++;

     return nHash;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 第一个是对除字符串类型以外的类型做hash（会先将结构体强转成const char*型，再计算。），第二个是对字符串做hash运算。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要预分配的桶的数量是多少，什么时候该增长，如何增长？&lt;br/&gt;
 这也是关于hash实现很重要的问题。我采用的是STL中的方法：预先定义28个质数，初始化时桶的数量是第一个质数，当插入数据太多，导致桶的数量 小于存储的对象数量时，重新分配一个更多的hash桶数（即采用更大的一个质数）。这28个质数使用数组存储，并定义一个函数来获取更大的一个质数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; // 注意：假设 long 至少有 32 bits
     static const u32 DEFAULT_PRIME_NUM = 28;
     static const u32 __primlist[DEFAULT_PRIME_NUM] =
     {
         53,         97,           193,         389,       769,
         1543,       3079,         6151,        12289,     24593,
         49157,      98317,        196613,      393241,    786433,
         1572869,    3145739,      6291469,     12582917,  25165843,
         50331653,   100663319,    201326611,   402653189, 805306457, 
         1610612741, 3221225473ul, 4294967291ul
     };

     // 以下找出上述28个质数之中，最接近并大于n的那个质数
     inline u32 __hash_next_prime(u32 n)
     {
         for (u32 dwIndex = 0; dwIndex &amp;lt; DEFAULT_PRIME_NUM; dwIndex++)
         {
             if (__primlist[dwIndex] &amp;gt;= n)
             {
                 return __primlist[dwIndex];
             }
         }
         return __primlist[DEFAULT_PRIME_NUM-1];
     }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hashtable 中的内存管理如何实现？是实现一个小对象的内存管理器？&lt;/p&gt;

&lt;p&gt; 这是涉及hashtable中的内存管理。在STL中是使用ListNode的小对象内存分配器（即&lt;code&gt;node_allocator&lt;/code&gt;），我实现得简单些。在hashtable内部维护一个空闲链表，即存储空闲结点。在hashtable初始化时，预先分配100个空闲结点，当元素插入时，从链表中取一个空闲结点。如果空闲结点已分配完，则再预分配100个结点。当元素释放时，不释放空间，而是将结点放回到链表中。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;rbtree.h,ordered_map.h,ordered_set.h&lt;/h4&gt;

&lt;p&gt;STL中的map,set是用红黑树实现。红黑树是一种平衡的二叉搜索树，在删除、插入后要进行调整（rotate树中结点和颜色）来维护树的平衡。因为这个数据结构查询效率高（O(logn)），且每次插入删除所做的再调整（即rebalance树结点）的开销相对较合理，所以很多关联存储结构会采用红黑树来实现（比如Linux内核中的CFS调度器，STL中的map,set）。关于红黑树的实现，难点在于删除、插入后的再调整，调整的过程在一般教科书上都有讲述，网上也有一些开源的实现代码，在此不再赘述。&lt;/p&gt;

&lt;p&gt;在实现红黑树的过程中，要注意对结点指针的改变顺序比较小心，如果稍一疏忽，查bug调试过程会比较费力。&lt;/p&gt;

&lt;p&gt;在编码的时候遇到一个问题：一般都知道在类的构造函数中初始化所有的成员变量，但是如果构造函数中调用的函数使用了类的成员，必须要先在调用的函数前初始化这个成员变量，再调这个函数。我在编程中遇到了这个问题，debug了很久才找到原因。&lt;/p&gt;

&lt;p&gt;关于Map,Set的实现基于都是用rbtree封装了一层，直接调用它提供的接口即可实现。&lt;/p&gt;
</description>
                <link>/2014-10/a-minimal-container/</link>
                <guid>/2014-10/a-minimal-container</guid>
                <pubDate>Liquid error: undefined method `xmlschema' for "2014-10-29 08:20":String</pubDate>
        </item>

        <item>
                <title>Quicksort in Linked List</title>
                <description>&lt;p&gt;Quick sort is a common sort method for objects stored contiguously, such as arrays. Recently, while implement a list template, I trying to migrate quick sort method to doubly linked list. The basic ideas of implementing quicksort in arrays and in lists are same, also based on partition, but there's one thing  different: The list does not support random access based on index. This essay will discuss how to implement quicksort in the list.&lt;/p&gt;

&lt;!--more--&gt;


&lt;h3&gt;Swap List Nodes&lt;/h3&gt;

&lt;p&gt;When comes to sorting, it will involve the exchange of data between two objects in sequence to be ordered. In the list, this is the exchange of data between two list nodes. There are two methods for swaping list nodes.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;By Swaping Data of Nodes&lt;/p&gt;

&lt;p&gt;This is the simplest, most common method: Exchange datas stored in list nodes. C/C++ codes for &lt;code&gt;swap&lt;/code&gt; function like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; template &amp;lt;class T&amp;gt;
 void List&amp;lt;T&amp;gt;::Swap(T *data1, T *data2)
 {
     if (*data1 == *data2) return; 
     T tmp = *data1;
     *data1 = *data2;
     *data2 = tmp;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;By Manipulating Pointers of Nodes in List&lt;/p&gt;

&lt;p&gt;Sometimes, The cost of copying data of nodes is large. In this circumstance, we can operate pointers of nodes to achieve exchange of two nodes. C/C++ codes for &lt;code&gt;swap&lt;/code&gt; function like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; template &amp;lt;class T&amp;gt;
 BOOL List&amp;lt;T&amp;gt;::Swap(ListNode&amp;lt;T&amp;gt; *pos1, ListNode&amp;lt;T&amp;gt; *pos2)
 {
     if (pos1 == NULL || pos2 == NULL)
     {
         return FALSE;
     }
     if(pos1 == pos2)
     {
         return TRUE;
     }

     ListNode&amp;lt;T&amp;gt; *temp, *temp1; 
     if(pos1 == m_pHead &amp;amp;&amp;amp; pos2 == m_pTail)  /* swap the head node and the tail node */ 
     { 
         if(pos1-&amp;gt;m_pNext==pos2)/*only two nodes in list*/ 
         { 
             pos2-&amp;gt;m_pNext=pos1; 
             pos2-&amp;gt;m_pPrev=NULL; 
             pos1-&amp;gt;m_pPrev=pos2; 
             pos1-&amp;gt;m_pNext=NULL; 
             m_pHead = pos2; 
             m_pTail = pos1;
         } 
         else
         { 
             pos1-&amp;gt;m_pNext-&amp;gt;m_pPrev=pos2; 
             pos2-&amp;gt;m_pPrev-&amp;gt;m_pNext=pos1; 
             pos2-&amp;gt;m_pNext=pos1-&amp;gt;m_pNext; 
             pos1-&amp;gt;m_pPrev=pos2-&amp;gt;m_pPrev; 
             pos2-&amp;gt;m_pPrev = pos1-&amp;gt;m_pNext = NULL; 
             m_pHead = pos2;   /* assign new head node */ 
             m_pTail = pos1;   /* assign new tail node */ 
         }
     }
     else if(pos2 == m_pTail)    /* swap the tail node and any other node */  
     { 
         if(pos1-&amp;gt;m_pNext==pos2) /* swap the last two nodes */ 
         { 
             pos1-&amp;gt;m_pPrev-&amp;gt;m_pNext=pos2;
             pos2-&amp;gt;m_pPrev=pos1-&amp;gt;m_pPrev;
             pos2-&amp;gt;m_pNext=pos1; 
             pos1-&amp;gt;m_pPrev=pos2; 
             pos1-&amp;gt;m_pNext=NULL;
             m_pTail = pos1;    /* assign new tail node */ 
         } 
         else
         { 
             temp=pos2-&amp;gt;m_pPrev; 
             temp-&amp;gt;m_pNext=pos1; 
             pos1-&amp;gt;m_pPrev-&amp;gt;m_pNext=pos2; 
             pos1-&amp;gt;m_pNext-&amp;gt;m_pPrev=pos2; 
             pos2-&amp;gt;m_pPrev=pos1-&amp;gt;m_pPrev; 
             pos2-&amp;gt;m_pNext=pos1-&amp;gt;m_pNext; 
             pos1-&amp;gt;m_pPrev=temp; 
             pos1-&amp;gt;m_pNext=NULL; 
             m_pTail = pos1;  /* assign new tail node */ 
         } 
     } 
     else if(pos1 == m_pHead) /* swap the head node and any other node */ 
     { 
         if(pos1-&amp;gt;m_pNext==pos2) /* swap the first two nodes */ 
         { 
             pos2-&amp;gt;m_pNext-&amp;gt;m_pPrev=pos1; 
             pos1-&amp;gt;m_pNext=pos2-&amp;gt;m_pNext; 
             pos1-&amp;gt;m_pPrev=pos2; 
             pos2-&amp;gt;m_pNext=pos1; 
             pos2-&amp;gt;m_pPrev=NULL; 
             m_pHead=pos2;     /* assign new head node */
         } 
         else
         { 
             temp=pos1-&amp;gt;m_pNext; 
             temp-&amp;gt;m_pPrev=pos2; 
             pos1-&amp;gt;m_pPrev=pos2-&amp;gt;m_pPrev; 
             pos1-&amp;gt;m_pNext=pos2-&amp;gt;m_pNext; 
             pos2-&amp;gt;m_pPrev-&amp;gt;m_pNext=pos1; 
             pos2-&amp;gt;m_pNext-&amp;gt;m_pPrev=pos1; 
             pos2-&amp;gt;m_pNext=temp; 
             pos2-&amp;gt;m_pPrev=NULL; 
             m_pHead=pos2;    /* assign new head node */ 
         } 
     } 
     else /* swap any other two nodes except the head and tail node */ 
     { 
         if(pos1-&amp;gt;m_pNext==pos2) /* swap two adjacent nodes */ 
         { 
             temp=pos1-&amp;gt;m_pPrev; 
             pos1-&amp;gt;m_pPrev-&amp;gt;m_pNext=pos2; 
             pos1-&amp;gt;m_pNext-&amp;gt;m_pPrev=pos2; 
             pos1-&amp;gt;m_pPrev=pos2; 
             pos1-&amp;gt;m_pNext=pos2-&amp;gt;m_pNext; 
             pos2-&amp;gt;m_pNext-&amp;gt;m_pPrev=pos1; 
             pos2-&amp;gt;m_pNext=pos1; 
             pos2-&amp;gt;m_pPrev=temp; 
         } 
         else
         { 
             temp1 = pos1-&amp;gt;m_pPrev;
             pos1-&amp;gt;m_pPrev-&amp;gt;m_pNext=pos2; 
             pos1-&amp;gt;m_pNext-&amp;gt;m_pPrev=pos2; 
             pos1-&amp;gt;m_pPrev=pos2-&amp;gt;m_pPrev; 

             temp=pos1-&amp;gt;m_pNext;
             pos1-&amp;gt;m_pNext=pos2-&amp;gt;m_pNext; 

             pos2-&amp;gt;m_pPrev-&amp;gt;m_pNext=pos1; 
             pos2-&amp;gt;m_pNext-&amp;gt;m_pPrev=pos1; 
             pos2-&amp;gt;m_pNext=temp; 

             pos2-&amp;gt;m_pPrev=temp1; 
         } 
     } 
     return TRUE;
 }; 
&lt;/code&gt;&lt;/pre&gt;

 Function Description:

&lt;ul&gt;
&lt;li&gt;According to the position of two nodes, pointer operation has been processed for different circumstances.&lt;/li&gt;
&lt;li&gt;In this function, parameter &lt;code&gt;pos1&lt;/code&gt; must be located in front of &lt;code&gt;pos2&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;Implementation Quicksort in List&lt;/h3&gt;

&lt;p&gt;Quicksort is a classic sort algorithm, the main step[&lt;a href=&quot;http://en.wikipedia.org/wiki/Quicksort&quot;&gt;refer wikipedia&lt;/a&gt;] of sorting is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Pick an element, called a &lt;strong&gt;pivot&lt;/strong&gt;, from the array.&lt;/li&gt;
&lt;li&gt;Reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the &lt;strong&gt;partition&lt;/strong&gt; operation.&lt;/li&gt;
&lt;li&gt;Recursively apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Applying above steps in list has serveral difference from applying in an array. The list doesn't support random access, can't random access the K-th element, so select the first node as pivot every time when sort sub-sequence objects.&lt;/p&gt;

&lt;h4&gt;Implementation Steps&lt;/h4&gt;

&lt;p&gt;The list to be sorted is split into two sub-lists. For simplicity, select the first node as a pivot, and then comparing all the nodes with the pivot, pick the nodes with smaller values than pivot to the left sub-list, pick the nodes with greater values than pivot to the right sub-list. After that, insert the pivot into list, as a bridge connecting the two sub-lists. Finally, recursively apply these steps to the left sub-list, right sub-list.&lt;/p&gt;

&lt;p&gt;There is a little trick in &lt;code&gt;partition&lt;/code&gt; step. In fact, Implementing &lt;code&gt;partition&lt;/code&gt; just need traverse once the linked list. The methods is: Define two pointers &lt;code&gt;pslow&lt;/code&gt;, &lt;code&gt;pfast&lt;/code&gt;, &lt;code&gt;pslow&lt;/code&gt; initialized to the head node of the list, &lt;code&gt;pfast&lt;/code&gt; initialized to the next node after the head node; Using &lt;code&gt;pslow&lt;/code&gt; as pointer to the last node of sub-list with smaller values than pivot , using &lt;code&gt;pfast&lt;/code&gt; traverse the list. Every time encounter a smaller node than pivot, move &lt;code&gt;pslow&lt;/code&gt; to the next node, then swap the &lt;code&gt;pslow&lt;/code&gt; node and &lt;code&gt;pfast&lt;/code&gt; node.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Swap Data of Nodes Version&lt;/p&gt;

&lt;p&gt;This version of quicksort is using swap method by swaping data of nodes. C/C++ codes for &lt;code&gt;quicksort&lt;/code&gt; function like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; template &amp;lt;class T&amp;gt;
 void List&amp;lt;T&amp;gt;::__sort_list(ListNode&amp;lt;T&amp;gt; *begin, ListNode&amp;lt;T&amp;gt; *end)  
 /* begin pointer to the fisrt node of list, end pointer to the last node of list */
 {
     if(begin == NULL || end == NULL)
         return;  
     if(begin == end)  
         return;  
     ListNode&amp;lt;T&amp;gt; *pslow = begin;  
     ListNode&amp;lt;T&amp;gt; *pfast = begin-&amp;gt;m_pNext;  
     while(true)  
     {  
         if(pfast-&amp;gt;m_tData &amp;lt; begin-&amp;gt;m_tData)            /* select the first node as a pivot */
         {   
             pslow = pslow-&amp;gt;m_pNext;
             /* pslow always pointer to the last node of sub-list with smaller values than pivot */
             Swap(&amp;amp;pslow-&amp;gt;m_tData, &amp;amp;pfast-&amp;gt;m_tData);    
         }  
         pfast = pfast-&amp;gt;m_pNext;
     }  
     /* pslow pointer to the proper position of list which pivot should stored at this moment */
     Swap(&amp;amp;pslow-&amp;gt;m_tData , &amp;amp;begin-&amp;gt;m_tData);  
     /* recursively apply __sort_list function to the left sub-list, right sub-list */
     __sort_list(begin, pslow);
     __sort_list(pslow-&amp;gt;next, end);
 };
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Manipulate Pointers of Nodes Version&lt;/p&gt;

&lt;p&gt;This version use swap method by manipulating pointers of nodes in List. C/C++ codes for &lt;code&gt;quicksort&lt;/code&gt; function like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; template &amp;lt;class T&amp;gt;
 void List&amp;lt;T&amp;gt;::__swap_ptr(ListNode&amp;lt;T&amp;gt; **pos1, ListNode&amp;lt;T&amp;gt; **pos2)   /* swap two pointer of list nodes */
 {
     if (*pos1 == *pos2)
     {
         return;
     }
     ListNode&amp;lt;T&amp;gt; *tmp = *pos1;
     *pos1 = *pos2;
     *pos2 = tmp;
 };   

 template &amp;lt;class T&amp;gt;
 void List&amp;lt;T&amp;gt;::__sort_list(ListNode&amp;lt;T&amp;gt; *begin, ListNode&amp;lt;T&amp;gt; *end)
 {
     if(begin == NULL || end == NULL)  
         return;  
     if(begin == end)  
         return;  
     ListNode&amp;lt;T&amp;gt; *pslow = begin;  
     ListNode&amp;lt;T&amp;gt; *pfast = begin-&amp;gt;m_pNext;  
     ListNode&amp;lt;T&amp;gt; *ptemp = NULL, *ptemp1 = NULL, *pEndFlag = NULL;
     pEndFlag = end;
     while(true)  
     {  
         ptemp = pfast;
         ptemp1 = pfast-&amp;gt;m_pNext;
         if(pfast-&amp;gt;m_tData &amp;lt; begin-&amp;gt;m_tData)    /* select the first node as a pivot */  
         {   
             pslow = pslow-&amp;gt;m_pNext;
             /* pslow always pointer to the last node of sub-list with smaller values than pivot */
             Swap(pslow, pfast);                
             __swap_ptr(&amp;amp;pslow, &amp;amp;pfast);   /* attention! */
         }  
         if (ptemp == pEndFlag || ptemp == NULL)
         {
             break;
         }
         pfast = ptemp1;
     }  

     BOOL32 bIsPivotLeft = FALSE, bIsPivotRight = FALSE;
     if (pslow == begin)
     {
     /* the proper postion pivot stored is leftmost of the list, so there is no need to sort left sub-list */  
         bIsPivotLeft = TRUE;        
     }
     if (pslow == end)
     {
     /* the proper postion pivot stored is rightmost of the list, so there is no need to sort right sub-list */ 
         bIsPivotRight = TRUE;      
         end = begin;
     }
     /* pslow pointer to the proper position of list which pivot should stored at this moment */
     Swap(pslow, begin);              
     __swap_ptr(&amp;amp;pslow, &amp;amp;begin);      /* attention! */

     /* recursively apply __sort_list function to the left sub-list, right sub-list */
     ListNode&amp;lt;T&amp;gt; *pLeftEnd = pslow-&amp;gt;m_pPrev;
     ListNode&amp;lt;T&amp;gt; *pRightBegin = pslow-&amp;gt;m_pNext;
     if (bIsPivotLeft == FALSE)
     {
         __sort_list(begin, pLeftEnd); 
     }

     if (bIsPivotRight == FALSE)
     {
         __sort_list(pRightBegin, end);
     }
 };
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;Points for Attention&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Swap&lt;/code&gt; function just operates pointers inside list nodes, such as &lt;code&gt;m_pPrev&lt;/code&gt;, &lt;code&gt;m_pNext&lt;/code&gt;, it dosen't modify the value of two nodes pointers passed by function. It meams &lt;code&gt;pos1&lt;/code&gt;,&lt;code&gt;pos2&lt;/code&gt; still pointer to the nodes with origin value. Therefore, after calling &lt;code&gt;Swap&lt;/code&gt;, we must swap two pointers' value using &lt;code&gt;__swap_ptr&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;I implemented quicksort in doubly linked list, you can see C/C++ codes in &lt;a href=&quot;https://github.com/baozh/container/blob/master/include/list.h&quot;&gt;file&lt;/a&gt;.&lt;/p&gt;
</description>
                <link>/2014-10/quicksort-in-list/</link>
                <guid>/2014-10/quicksort-in-list</guid>
                <pubDate>Liquid error: undefined method `xmlschema' for "2014-10-05 08:20":String</pubDate>
        </item>

        <item>
                <title>Linux Bash Vulnerability: ShellShock</title>
                <description>&lt;p&gt;French Linux enthusiasts Stéphane Chazelas in mid-September 2014, discovered the famous BASH SHELL implementation vulnerability (ShellShock, number CVE-2014-6271), it can execute script code by constructing environment variables. This vulnerability can affect a large number of linux application interact with bash, so that the America National ​​Security Division score this vulnerability 10 points, this is the most devastating score. This essay mainly discusses about the condition of the loophole occurrence, principle analysis, and vulnerability remediation methods.&lt;/p&gt;

&lt;!--more--&gt;


&lt;h3&gt;Origin and Description of Vulnerability&lt;/h3&gt;

&lt;p&gt;Vulnerability Information has been firstly described in the 34,765 vulnerability report from exploit-db, a well-known vulnerabilities website, the paper gives a validation command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;    env x='() { :;}; echo vulnerable' bash -c &quot;echo this is a test&quot;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If execute this command in linux/unix bash(Bash 4.3 or earlier version), you may get the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vulnerable
this is a test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the first line of result appear &lt;code&gt;vulnerable&lt;/code&gt;, illustrate the system has a vulnerability of arbitrary commands execution caused by bash implementation bug. This problem exists GNU Bash 4.3 and earlier versions. Through adding some string after function definition in environment variable values, an attacker can change or bypass environmental restrictions to execute Shell command.&lt;/p&gt;

&lt;h3&gt;Condition of Vulnerability Occurrence&lt;/h3&gt;

&lt;p&gt;Any known application, as long as the following two conditions are met, it can be used to execute arbitrary commands via bash vulnerability:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The program uses bash at some point processing environment variable assignments;&lt;/li&gt;
&lt;li&gt;The environment variable assignments string depending on user input.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Affected severely are the Apache servers using mod_cgi or mod_fcgid module, and must meet:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;After server receives the request, it will execute bash.&lt;/li&gt;
&lt;li&gt;When execute bash, it will set as environment variables like UserAgent.&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;Demonstration of Exploit Vulnerability, and Principle Analysis&lt;/h3&gt;

&lt;p&gt;Here is the test script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;    $ curl -A ‘() { :; }; /bin/cat /etc/passwd &amp;gt; dumped_file’ http://192.168.0.1/poc.cgi 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;poc.cgi is a cgi script beginning with &lt;code&gt;#! /bin/bash&lt;/code&gt;.&lt;br/&gt;
On the server side things will happen:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Receives an HTTP request, the request with the Head&lt;code&gt;User-Agent: () {:;}; / bin / cat / etc / passwd&amp;gt; dumped_file&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The server set User-Agent as environment variable, and execute bash.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Because of bash parsing vulnerability, it execute the following script:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;        $ /bin/cat /etc/passwd &amp;gt; dumped_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When shell interpreter deal with environment variable assignment, it execute the command after the function body. But the value of environment variable is a string, how was it transform into a function?&lt;/p&gt;

&lt;p&gt;In fact, this is related to Bash Implementation. Define a function in Bash, the format is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;    function function_name() {
        body;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If Bash parser find a small brackets and braces while initializing environment variables, it treate the string as a function definition.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;    [root@baozenghui ~]$ say_hello='() { echo hello world; }'
    [root@baozenghui ~]$ export say_hello
    [root@baozenghui ~]$ bash -c 'say_hello'
    hello world 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing the above code in the new Bash process, &lt;code&gt;say_hello&lt;/code&gt; became a function in the new environment, its evolution as follows:
1. A new bash process scans at initialization, find parentheses and braces after environment variable &lt;code&gt;say_hello&lt;/code&gt;, figuring it's a function definition.
2. Bash set &lt;code&gt;say_hello&lt;/code&gt; as a function name, and its value as a function of the body.&lt;/p&gt;

&lt;p&gt;By combining patch, analysis Bash source code, in fact, Bash actually want to initialize environment variables and define some functions at startup,&lt;/p&gt;

&lt;p&gt;By combining patch, analyzing Bash source code, in fact, Bash actually want to define some environment variables and functions at startup, the initialization way is to execute variable assignment statements(such as &lt;code&gt;name = value&lt;/code&gt; format), when encounter a function definition, convert it into a function, that's all the thing it wanted to do. But when bash scanning into the function definition, converting it into a function, it accidentally execute the next command for the sake of no comprehensive consideration when parsing. Therefore, statements added to determine the legality of the function body in the patch:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;    #define SEVAL_FUNCDEF 0x080       /* only allow function definitions */
    #define SEVAL_ONECMD  0x100       /* only allow a single command */
    if ((flags &amp;amp; SEVAL_FUNCDEF) &amp;amp;&amp;amp; command-&amp;gt;type != cm_function_def)
    {
        //illegal, not a function definition.
        break;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Vulnerability Remediation&lt;/h3&gt;

&lt;p&gt;In UTC Time September 25, 2014 morning, CVE-2014-7169 vulnerability has been repaired by BASH community, the major GNU/Linux distributions, including Debian, Gentoo, OpenSUSE, CentOS, RHEL, have provided relevant upgrade.&lt;/p&gt;

&lt;p&gt;centos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;    $ yum clean all 
    $ yum makecache 
    $ yum -y update bash 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ubuntu:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;    $ apt-cache gencaches 
    $ apt-get -y install --only-upgrade bash 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;debian:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;    $ apt-cache gencaches 
    $ apt-get -y install --only-upgrade bash
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Related Links:&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://access.redhat.com/security/cve/CVE-2014-6271&quot;&gt;Link1&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://securityblog.redhat.com/2014/09/24/bash-specially-crafted-environment-variables-code-injection-attack/&quot;&gt;Link2&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/2014-10/linux-bash-vulnerability-ShellShock/</link>
                <guid>/2014-10/linux-bash-vulnerability-ShellShock</guid>
                <pubDate>Liquid error: undefined method `xmlschema' for "2014-10-02 08:20":String</pubDate>
        </item>

        <item>
                <title>A Simple Practice of Implementing String Class</title>
                <description>&lt;p&gt;Recently I read chenshuo's blog, &lt;a href=&quot;http://coolshell.cn/articles/10478.html&quot;&gt;《A proper implementation of string class in C++ interview》&lt;/a&gt;，the article shows beautiful implementation of a minimalist string class, but not support some complex operator,such as [],==,&amp;lt;，no exception handing. So I try to implement a string class, supplement some remaining function, including exception handing and testing.&lt;/p&gt;

&lt;!--more--&gt;


&lt;h3&gt;Requirements&lt;/h3&gt;

&lt;p&gt;The specific requirements are these:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Support conversion from/to traditional c string.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;string object -&gt; c_str()&lt;/li&gt;
&lt;li&gt;c string -&gt; string object&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Support [] operator, modify a character in a string object.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;Overloaded operator =, ==, &gt;, &amp;lt;, +, +=.&lt;/li&gt;
&lt;li&gt;Some handy function, such size(),empty().&lt;/li&gt;
&lt;li&gt;String object can use as value type of standard container,such as vector/list/deque.&lt;/li&gt;
&lt;li&gt;String object can use as key type of map/unordered_map.&lt;/li&gt;
&lt;li&gt;Support exception handing: it's best to specify a custom function to handing &lt;code&gt;new&lt;/code&gt; failure, when allocating string space.&lt;/li&gt;
&lt;li&gt;Support testing: Write test case(use google test, or Boost test framework) to test all kinds of unexpected circumstances.&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;Design&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;when the system unable to allocate the request memory, how to handling?&lt;br/&gt;
Generally, there are two ways to haneling this situation.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;use &quot;nothrow&quot; form of new operator, write codes like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   Widget *pwd = new (std::nothrow) Widget;
   if (pwd == NULL)
   {
       ...
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;set a handler to handling allocating failure.&lt;br/&gt;
Befor operator new throws an exception in response to an unsatisfiable request for memory, it calls a client-specifiable error-handling function called a new-handler. You can call &lt;code&gt;set_new_handler&lt;/code&gt; function to set it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   void outOfMen()
   {
       std::cerr &amp;lt;&amp;lt; &quot;Unable to satisfy request for memory.&quot;;
       std::abort();
   }

   int main()
   {
       std::set_new_handler(outOfMen);
       int *pBigDataArray = new int[100000000L];
       ...
   }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; In this place, I write a class &lt;code&gt;NewHandlerHolder&lt;/code&gt;，inherited by string class to set a class-specfic new-handler. when dynamically allocating string object failed, it will call new-handler setted in string class.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;string class support value type, key type of standard container.&lt;br/&gt;
Sequential container(such as vector, deque, list,etc.) can keep any type objects, but some container operation requires that value type class implement some operator, such as &lt;code&gt;&amp;lt;&lt;/code&gt; operator for sort operation. For the associative containers(map, multimap, set, and multiset), the key type must define a way to compare the elements. By default, the library uses the &amp;lt; operator for the key type to compare the keys. In the set types, the key is the element type; in the map types, the key is the first type.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;testing&lt;br/&gt;
Use boost test framework to test every function in string class. Write test cases to test all kinds of success or failure.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;Implementation&lt;/h3&gt;

&lt;p&gt;Generally, there are three way to  implement string class:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Eager Copy&lt;br/&gt;
This has no special processing. The code skeleton like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; class string
 {
 public:
     char *begin() {return start;}
     char *end() {return start+size;}
     size_t size() const {return size;}  
     size_t capacity() const {return capacity;}
     ...
 private:
     char *start;
     size_t size;
     size_t capacity;
 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Data structure schematic diagram like this:&lt;br/&gt;
&lt;img src=&quot;/assets/images/string1.png&quot; alt=&quot;aaa&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SSO(short-string-optimized)&lt;br/&gt;
It has local buffer to store short string, if the string too large to keep in local buffer, it will store it in a dynamic memory space addressed by &lt;code&gt;start&lt;/code&gt; pointer.The code skeleton like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; class string
 {
 public:
     //some access function
     ...
 private:
     char *start;
     size_t size;
     static const int kLocalSize = 15;
     union
     {
         char buffer[kLocalSize+1];
         size_t capacity;
     }data;
 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The memory layout like this:&lt;br/&gt;
&lt;img src=&quot;/assets/images/string2.png&quot; alt=&quot;bbb&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If the string too large to store in the buffer, it will dynamically allocate a space in heap pointed by start to store string.&lt;br/&gt;
&lt;img src=&quot;/assets/images/string3.png&quot; alt=&quot;ccc&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;COW(Copy-On-Write)&lt;br/&gt;
Copy a string with no modification, it will actually not copy all char string, just increase it's referance count. While copy a string with some modification, or directly modify one more char in string, it will reallocate a new space to store new string, and revise referance count.The code skeleton like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; class string
 {
 public:
     //some access function
     ...
 private:
     struct Rep
     {
         size_t size;
         size_t capacity;
         size_t refcount;
         char *data[1];
     };
     char *start;
 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The memory layout like this:&lt;br/&gt;
&lt;img src=&quot;/assets/images/string4.png&quot; alt=&quot;ddd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Andrei Alexandrescu advise we should choose right version of string for different application Scenarios. For short strings, use SSO version; For strings of medium length, use Eager Copy version; For large strings, use COW version. You can profiling to decide s to use which version of string.&lt;/p&gt;

&lt;p&gt;I implement Eager Copy version, and SSO version string, the code is in &lt;a href=&quot;https://github.com/baozh/string/blob/master/include/string_eager.h&quot;&gt;file1&lt;/a&gt;, &lt;a href=&quot;https://github.com/baozh/string/blob/master/include/string_sso.h&quot;&gt;file2&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>/2014-05/a-simple-practice-of-implementing-string-class/</link>
                <guid>/2014-05/a-simple-practice-of-implementing-string-class</guid>
                <pubDate>Liquid error: undefined method `xmlschema' for "2014-05-26 08:20":String</pubDate>
        </item>

        <item>
                <title>shell练习：批量修改目录下的文件后缀名</title>
                <description>&lt;p&gt;上个星期组长给我分配了一个任务，要将一个目录下的所有子目录的文件名转换成小写，文件的内容中有路径的也将转换成小写，功能可以用任何编程语言实现。我想了一下，这个用shell实现最方便，只需要一个函数遍历子目录，另一个函数做文件名替换的工作。&lt;/p&gt;

&lt;!--more--&gt;


&lt;p&gt;具体的功能要求：&lt;br/&gt;
1. 遍历一个文件夹中的所有子目录，将有大写后缀名的文件改成小后缀名的文件。&lt;br/&gt;
2. 遍历一个文件夹中的所有子目录，将目录中的文件内容(一般存有一个文件的路径)中含有大写后缀名，转换成小写。&lt;/p&gt;

&lt;h3&gt;修改文件后缀名，文件内容&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;sh 遍历当前目录下的文件，将文件中含有大写后缀名的内容，转换成小写&quot;&gt;modify_file()
{
    cd $1
    for file in *;
      do
        if [ -f $file ]
        then
            cat $file | sed 's/\..*/\L&amp;amp;/g' &amp;gt; &quot;$file&quot;.tmp
            mv -f &quot;$file&quot;.tmp $file
        fi
     done
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;sh 遍历当前目录下的文件，将文件的后缀名从大写改成小写&quot;&gt;renamefile()
{
    cd $1
    for file in *;
      do
        if [ -f $file ]
        then
            mv $file $(echo $file|sed 's/\..*/\L&amp;amp;/g')
        fi
     done
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面没有复杂的东西，只是那个sed表达式&lt;code&gt;sed 's/\..*/\L&amp;amp;/g'&lt;/code&gt;折腾了好久。&lt;/p&gt;

&lt;h3&gt;遍历目录下的所有子目录&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;sh 递归遍历一个目录下的所有子目录(深度优先遍历）&quot;&gt;recusivedir()
{
    modify_file &quot;./&quot;

    for dir in `ls .`
    do
       if [ -d $dir ]
       then
         echo $dir
         cd $dir

         recusivedir
         cd ..
       fi
    done
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;递归遍历当前目录的所有子目录，函数执行时先调modify_file()，renamefile()，然后深度优先遍历各个子目录。&lt;/p&gt;

&lt;p&gt;具体的可以看一下这两个示例代码，&lt;a href=&quot;https://github.com/baozh/code-snippets/blob/master/modify_file.sh&quot;&gt;代码1&lt;/a&gt;，&lt;a href=&quot;https://github.com/baozh/code-snippets/blob/master/rename.sh&quot;&gt;代码2&lt;/a&gt;。&lt;/p&gt;
</description>
                <link>/2014-03/modify-file-suffix/</link>
                <guid>/2014-03/modify-file-suffix</guid>
                <pubDate>Liquid error: undefined method `xmlschema' for "2014-03-23 14:20":String</pubDate>
        </item>

        <item>
                <title>[转]求知成瘾，却无作品</title>
                <description>&lt;p&gt;文/紫松&lt;/p&gt;

&lt;p&gt;激励是人学习的关键因素。可当知识本身成为求知的激励，你已求知成瘾，进入了好学的骗局。&lt;/p&gt;

&lt;!--more--&gt;


&lt;h3&gt;求知瘾者的诞生&lt;/h3&gt;

&lt;p&gt;求知欲似乎是人们的本能，尤其「好学」这个词被定义成天生的褒义之后，他人习惯性地会对好学的人大加赞赏，好学者亦会视自己强烈的求知欲弥足珍贵。当一些好学者碰到金融，科技，人文，社会这些「靓丽」的词汇时，依靠从小的信条『知识就是力量』判断：海纳百川，学了没错。于是，伴随着知识和见识增长带来的优越感和满足感，好学者充分利用时间涉更广的猎，读更多的书，翻更丰富的杂志。兴趣虽多，终得确定职业方向，但是对这些好学者而言，选择一个领域，就会「喜欢」这个领域的一切，但非不排斥的东西，便来者不拒。 「只接受什么信息」对他们来说没有概念，他们只有「只不接受什么东西」，他们认为这是在拓展知识和见识。选择了一个领域之后，他们依然没有放松对其他领域的关注，他们琢磨的是『那些大牛看上去就是什么都懂，对什么问题都有见识，我更应求知好学，集思广益了』，于是，听到大家之言便如获至宝，长期泡各种公开课，罗辑思维，晓说，看各种长知识长见识的视频节目，他们总是认为自己发现了一个又一个好的东西。至此，一个好学者依据知识和见识增长带来的优越感和满足感以及好学本身的自我激励作用进化成了「求知瘾者」。&lt;/p&gt;

&lt;h3&gt;求知瘾者的特点之「能思考，欠全面」&lt;/h3&gt;

&lt;p&gt;求知瘾者特点之一就是：能就一个主题提出很多问题，却不能系统地提出一系列问题；能回答一个领域的很多问题，却不能前呼后应地回答一系列问题。这是典型的能思考，欠全面。这样的人给出的问题的答案也常是一种虚假的深刻。&lt;/p&gt;

&lt;h3&gt;求知瘾者的特点之「擅洞察远端事物的变化，却不善捕捉身边细腻的情感」&lt;/h3&gt;

&lt;p&gt;求知瘾者的另一个特点就是：喜欢观浪潮之巅，能感知领域格局的风云突变，偏爱高屋建瓴。因为求知瘾者所接受的知识多来源于书，别人的言论，网上的文字，无暇将生活本身当老师，生活可能会遇到各种问题，并不灵光。&lt;/p&gt;

&lt;h3&gt;求知瘾者的特点之「有见识，无作品」&lt;/h3&gt;

&lt;p&gt;求知瘾者的最悲哀的一个特点就是：因为求知成瘾而知识储备尚可，因为求知成瘾而见识不俗，因为求知成瘾而鲜有作品。当知识本身成为求知的激励，当知识激励给与了求知瘾者足够的满足感，作品创作成了求知瘾者无法触碰的禁地。作品难创，知识易得，当求知占用作品创作的精力，当用求知去填补作品创作的寂寞，原本的作品创作驱动求知变成了求知成瘾逃离作品创作。&lt;/p&gt;

&lt;h3&gt;「罗辑思维」与求知成瘾&lt;/h3&gt;

&lt;p&gt;在我写下这篇文章时，「罗辑思维」已是办的最好的自媒体之一，天天坚持产出高质量内容，并且已经形成了自己的罗辑思维社区。新颖的切入点，有趣的观察角度，与众不同的思维方式。或开启心智，或传播知识，或颠覆三观，或答疑解惑，它总能为你带去一样。用罗胖自己的话说：『既不是心灵鸡汤，也不是知识短文。和大家的兴趣捉迷藏，和自己知识较劲，力图给大家讲一些自己知识边缘以外的东西。』罗胖的目标是和社区人群一起成长。知识，见识，成长，非心灵鸡汤式的，足以俘获很多人的心肝。&lt;/p&gt;

&lt;p&gt;可是对于求知成瘾者而言，这只不过是又一个「知识」获取平台，由罗胖提供而已。在这里，求知成瘾者如愿以偿地获得了更多问题的答案，更多事物的看法，更多的社会杂谈。&lt;/p&gt;

&lt;p&gt;作为一个新媒体，「罗辑思维」做着出色的探索和有益的事；作为立足未稳的年轻人，求知瘾者却把自己生活中的主要角色定义为一个求知的听众。没有那么多的解惑诉求，却天天被解惑；不需要每天一点新视野，却天天去吃视野快餐。有人也许会说这只是占用每天的几分钟时间而已，权当消遣亦无妨。可惜这只是求知瘾者盲目求知的一个缩影，求知瘾者还会抽出更多的「消遣」时间去求知，越发地没有时间和精力在某个方向去做深入的研究，更没有什么能力去创作作品。罗胖的作品往大了说有创办的「罗辑思维」，往小了说有他对媒体和互联网的一些研究成果；求知瘾者有什么呢？&lt;/p&gt;

&lt;p&gt;不一定要那么大众，那么出彩，那种形式，才算作品。不同的人，不同的阶段对作品都有着不同的定义。作品也有拿的出手的和拿不出手的之分。但如果你对「作品」完全没有了创作欲望或决心又碰巧是个好学的人，那么我说的求知瘾者可能就是你。&lt;/p&gt;

&lt;h3&gt;多说一句&lt;/h3&gt;

&lt;p&gt;就像我在自己写的&lt;a href=&quot;http://jianshu.io/p/xnHyFg&quot;&gt;《穷的只剩逻辑的穷逼》&lt;/a&gt;中直接标明自己是较严重的「逻辑瘾者」，本文中的「求知瘾者」依然是在写自己。这些瘾不是什么好事，戒掉最好！&lt;/p&gt;

&lt;p&gt;原文转自&lt;a href=&quot;http://jianshu.io/p/Daxrnq&quot;&gt;简书&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/2014-02/knowledge-addiction/</link>
                <guid>/2014-02/knowledge-addiction</guid>
                <pubDate>Liquid error: undefined method `xmlschema' for "2014-02-16 01:48":String</pubDate>
        </item>

        <item>
                <title>如何记忆</title>
                <description>&lt;p&gt;关于记忆有很多方法论，这里只是记录一下我的一些胡思乱想。&lt;/p&gt;

&lt;h3&gt;工作上的问题&lt;/h3&gt;

&lt;p&gt;最近工作上老是健忘，很多内容想不起来，比如一个项目中某个程序段的位置，很久以前改的bug的位置，某个linux命令，gdb调试命令，telnet调试命令，wireShark过滤表达式的语法，正则表达式的语法......这些内容中常用的需要记忆的知识其实不多，自己花时间强记一下，应该不会太难。可是最近工作时，老是想不起来，经常要翻笔记，才能慢慢回忆起来。&lt;/p&gt;

&lt;!--more--&gt;


&lt;p&gt;自己反思了一下，主要有几个原因：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;学得越多，忘得越快。&lt;/strong&gt;&lt;br/&gt;
记得之前微博上&lt;a href=&quot;http://www.weibo.com/2652916941/AsBgWdArl&quot;&gt;一位朋友说道&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;累到极点，头脑麻痹的时候，连自己叫什么，电话是什么都会忘记。我上周经历了一次，怎么都想不起来自己的电话号码，幸好还记得自己叫什么，记得老婆的电话号码。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;  我回复道：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;搞编程的好像经常会这样。大脑的存储容量有限，就像缓存一样，会造成局部信息的换入换出。所以，可以把一些重要信息(电话号码、帐号...)记录下来，减少记忆负担。把工作中经历的难题记录下来，减少再回忆时的时间。没时间记录的话，可简单做一个索引类的标识，以便以后查阅。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;  去年下半年刚工作，需要学习的知识特别多。我喜欢在周末或者晚上有空的时候充电，学习一些自己感兴趣、与工作无关的一些知识。这样导致工作的内容经常会忘掉，或者要花很长一段时间才能回忆起来。我问了下我周围的同事，他们都没有这个问题。我比较要好的一位同事(兼好朋友)说他业余时间基本不学习，只是在工作的时候学习，尽量保证在工作的8小时内高效学习、高效工作，他思路很清晰，很少忘记知识。&lt;/p&gt;

&lt;p&gt;  人的大脑的记忆容量是有限的，当超出了记忆容量，大脑会把之前记忆的一部分内容清空，腾出空间记忆新的内容。而记忆又分短期记忆和长期记忆，短期记忆是刚接触的、刚记忆的新内容，还不稳固。长期记忆是经过不停地重复，在大脑已形成根深蒂固的印象的内容。比如自己的名字，电话号码。而大脑容量不够时，经常会换出短期记忆，然后将新学的知识填入腾出的空间。&lt;/p&gt;

&lt;p&gt;  下半年刚工作，工作上学习的内容基本是刚接触，还不稳固，属于短期记忆。而业余学的知识也特别多特别新，不稳固，也属于短期记忆。所以当大脑容量不够时，两块内容不停地在大脑中换入换出，导致短期记忆形成不了长期记忆，记忆效率降低了，工作效率也降低了。&lt;/p&gt;

&lt;p&gt;  后来我改变了学习策略，业余时间只学习自己感兴趣、与工作相关比较多的知识。这样在学习时，大脑不需要切换思维，学习效率高。而且工作上的内容也不容易忘记。等我工作久了，工作上的内容已经烂熟于心了(形成了长期记忆)，再考虑业余时间学习与工作无关的内容。试了一下，感觉效果还不错。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;过于依赖笔记，依赖记录的文本内容。导致了记忆惰性。&lt;/strong&gt;&lt;br/&gt;
之前养成了学习记笔记的习惯，应该说这是一个好习惯，但也有一些副作用。在工作的时候，总是把一些遇到的问题记在本子上，不用心记住，总是觉得下次遇到，不停地重复，会自然而然记住的。然后每次Team leader过来问我的时候，自己总是支支吾吾，因为很多内容没记住，当时回答不出来。后来想了下，可能是因为平时养成了记笔记的习惯，导致不用心记忆内容，记忆能力得不到训练，记忆力下降了。后来，我摸索的解决方法是：工作上的内容一定要强行记忆，就算那块内容不重要、或者遇到的机会不多，也要强行记住。工作中交给的任务、尝试的方法、自己的思考也要记住，因为Team leader会问到。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;年纪大了，记忆力没以前好了。&lt;/strong&gt;&lt;br/&gt;
这个原因应该每个人都有。大脑像一台精密的机器，当运行久了，会磨损、效率降低。所以运行一段时间后要停下来休息，加加油，润滑机器。当然，也不能停下来太长时间。大脑是需要训练的，越训练能力越大，速度越快。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;记忆的小技巧&lt;/h3&gt;

&lt;p&gt;我想分享一下关于记忆的小技巧。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;分清什么是需要快速强行记住的，什么是可以偷懒不记忆的。&lt;/strong&gt;&lt;br/&gt;
这个很重要。也就是分清记忆的轻重缓急，急的重要的要快速强行记住，不重要的不紧急的可以先记下笔记，以后遇到了不停地重复，会慢慢记住。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;减少记忆负担。&lt;/strong&gt;&lt;br/&gt;
一直感觉程序员是特别累的，要学那么多知识，要记忆那么多知识，所以应该给自己适当减负。减负的方式有多种：比如砍掉不需要记忆或者不重要的内容；用一些电子工具(比如手机,ipad)把灵光一现的想法随时记录起来；养成记笔记的习惯；通过一些方式简化记忆的内容，让它容易记住。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;记笔记。&lt;/strong&gt;&lt;br/&gt;
这是一个久试不爽的秘诀。烂笔头胜过好记性。对于一些重要的、但是以后重复机会不多的知识，要记笔记。以后再遇到的话，只要查阅一下笔记就行了，减少再回忆的时间。怎么做笔记也是一门学问。如果时间比较充裕的话，我会记录得比较详细。时间比较少的情况下，会减少记笔记的量，只做索引。一般来说，时间都是比较紧的。我会把资料保存成文本文件，在文件中做一些批注、重要的加一些颜色标识，摘录一些重要的句子保存下来。看书时就在书上写写划划，在旁白做批注。把重要的点在目录或首页空白处中标注、记录。&lt;/p&gt;

&lt;p&gt;  另外，不要依赖于笔记，小心记笔记导致的记忆惰性。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;练习记忆，训练自己的记忆能力。&lt;/strong&gt;&lt;br/&gt;
好刀经常不用会生锈，好的大脑经常不使用也会退化。平时应该有心培养自己的思考能力、记忆能力。比如通过演讲、多沟通、把自己学到的时候用简单的语言复述给别人听，通过多重复多训练，提高自己的记忆能力。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;其实记忆是很不可靠的，几乎所有几年前的记忆都会忘掉，而平时记笔记的时间又很少，所以如何有效做知识的索引，很重要。就像刘未鹏所说的，&lt;a href=&quot;http://mindhacks.cn/2009/03/28/effective-learning-and-memorization/&quot;&gt;&lt;strong&gt;你所拥有的知识并不取决于你记得多少，而在于它们能否在恰当的时候被回忆起来。&lt;/strong&gt;&lt;/a&gt;当你想用到之前学过的某块知识的时候，能够快速找到，很重要。&lt;/p&gt;

&lt;h3&gt;如何快速找到项目中的某个目标代码段&lt;/h3&gt;

&lt;p&gt;很羡慕一些老员工快速找代码、快速定位问题的能力。我自己找某块代码时，总是要翻好几个文件，折腾一阵才能找到。自己摸索了一下，摸到了一些小窍门：首先要对项目的每个文件非常熟悉，然后找到目标文件，从目标文件中搜索关键词(比如函数名，容易记的标记名，bug号之类)。平时用心记忆很重要，要记住项目的特征，重要代码段的关键词是什么。&lt;/p&gt;

&lt;h3&gt;如何记忆Linux命令&lt;/h3&gt;

&lt;p&gt;Linux上的工具都是命令行工具，各个工具都有自己的一套命令，记忆这些命令是比较头疼的。我摸索了一些方法，分享一下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;记笔记。&lt;/strong&gt;&lt;br/&gt;
我平时有个小本子，专门记录常用的linux命令，比如各种shell命令，vim命令，gcc命令，gdb命令，make命令，git命令...平时遇到生僻的命令就记在本子上，使用到就查查。刚开始记这些笔记是比较花时间的，以后就是修修补补，不用花多少时间。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;用alias做成一个好记的别名。&lt;/strong&gt;&lt;br/&gt;
有的shell命令的参数特别难记，特别多，我记不住。就用alias命令将它重命名成一个好记的别名。比如tar(打包工具)经常要与gz,bz(压缩工具)结合使用，有一堆难记的参数，我就重命名成&lt;code&gt;tar_gz&lt;/code&gt;,&lt;code&gt;tar_ungz&lt;/code&gt;,&lt;code&gt;tar_bz&lt;/code&gt;,&lt;code&gt;tar_unbz&lt;/code&gt;，这样好记些。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;写成shell脚本。&lt;/strong&gt;&lt;br/&gt;
有的shell命令太长了，没法用alias重命名。就把常用的shell代码段用shell脚本包装一下，然后直接调shell脚本就行了。比如工作中会将编辑好的文件挂载到linux机器上进行编译调试，这个&quot;挂载&quot;命令太长了，我包装了一下，加了几个参数，以后直接调脚本方便多了，不用再记忆额外的东西了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;推荐阅读：&lt;/h3&gt;

&lt;p&gt;[1] &lt;a href=&quot;http://mindhacks.cn/2009/12/20/dark-time/&quot;&gt;暗时间&lt;/a&gt;，刘未鹏&lt;br/&gt;
[2] &lt;a href=&quot;http://mindhacks.cn/2007/05/24/learn-to-focus/&quot;&gt;学习密度与专注力&lt;/a&gt;，刘未鹏&lt;br/&gt;
[3] &lt;a href=&quot;http://mindhacks.cn/2009/03/28/effective-learning-and-memorization/&quot;&gt;如何有效地记忆与学习&lt;/a&gt;，刘未鹏&lt;br/&gt;
[4] &lt;a href=&quot;http://book.douban.com/subject/3609132/&quot;&gt;《把时间当作朋友》&lt;/a&gt;,李笑来&lt;/p&gt;
</description>
                <link>/2014-01/how-to-memory/</link>
                <guid>/2014-01/how-to-memory</guid>
                <pubDate>Liquid error: undefined method `xmlschema' for "2014-01-30 02:22":String</pubDate>
        </item>

        <item>
                <title>Google C++编程风格指南</title>
                <description>&lt;p&gt;前几个月阅读了&lt;a href=&quot;http://book.douban.com/subject/25716166/&quot;&gt;《从缺陷中学习C/C++》&lt;/a&gt;、&lt;a href=&quot;http://book.douban.com/subject/25708312/&quot;&gt;《C++ primer 5th》&lt;/a&gt;，两本书都由潘爱民老师做序，在序中推荐结合《Google C++ Style Guide》一起阅读，所以最近花了点时间读完了这份文档。&lt;/p&gt;

&lt;!--more--&gt;


&lt;p&gt;这份文档相当于是Google内部对C++的编码规范，阐述了在Google的项目中如何有效使用C++，应遵守哪些规范，避免C++的各种陷阱。对我来说，最有用的莫过于Google对C++的各种特性的取舍。C++是个由各个复杂特性组成的语言，在实际项目运用的时候总会困惑，是否要使用这个特性，应该如何使用，它的应用场合是什么。比如大家比较关心的：是否要使用异常，流的运用，智能指针的使用，函数重载、操作符重载如何运用，何时禁用拷贝构造函数和赋值操作符。&lt;/p&gt;

&lt;p&gt;明白一个C++特性的使用场合很重要。它的优点、缺点是什么，使用的度是什么。这些很难在读一些文章后完全理解，只有实践中积累经验、多思考，才能在实践运用自如。实际上，在阅读这份文档的时候，还有很多不理解的地方。比如为何要禁用拷贝构造函数和赋值操作符，为什么不使用流，为什么不使用操作符重载。现在C++的标准库，或者其它各类库都广泛运用了C++的各种特性，如果在项目中规定不使用某些特性，如何与这些库配合编程。&lt;/p&gt;

&lt;p&gt;最近经常思考的一个问题：如果在项目的编码规范中规定不使用某些特性，而使用的库却使用这个特性，那如何与这个库配合编程？比如常遇到一个问题：项目中规定不使用异常，但是在STL中使用异常的，如果STL抛出异常，你如何处理？一个广泛的例子是C++的new操作符，如果new失败，会默认抛出bad_alloc异常。可是在项目代码中，我要么看到不检查new的返回值，不catch异常，要么检查返回的指针是否为NULL。关于这点，《Effective C++》有比较好的论述。&lt;/p&gt;

&lt;p&gt;我们项目组使用C++的方式是偏C风格的，基本上是C+Class+STL，最多加一点继承。实际上STL用得也不多，基本上使用自己定制的一套基础库。这套编码规范在实际项目中的运用效果不错，但我感觉还是保守了一些，一些好的C++特性，可以提高生产效率的，没有使用到。相比之下，Google的编码风格更加开放一些(但是是有限制的开放)，或者说规定得更加严格、细致，尽量让各种特性的使用限制在一定范围内。&lt;/p&gt;

&lt;p&gt;这份文档也要有借鉴地使用，比如有些使用方式是Google特有的，不适合自己的项目场景(比如一些命名规范，某些C++特性的限制使用)，尽量借鉴其安全使用C++的思格(比如不让编译器做多余的动作，把自己的意图清晰地告诉编译器；限制编译器的自动推导，自动生成的代码)，在自己实践的过程中，摸索出自己的一套编码风格。尽量运用好C++的各种特性，提高生产率，又要安全，避免C++的各种陷阱，还要与项目组的其它代码保持一致性。&lt;/p&gt;

&lt;p&gt;在学习过程中，阅读别人写的代码也是一种好的学习方式。比如之前看过陈硕写的muduo网络库，代码写得很漂亮，很有Google的风格，它在代码中熟练运用C++的高级特性(boost库，function/bind，智能指针，其实主要是RAII、事件回调)，陈硕称之为&quot;现代C++的编码风格&quot;。还有Google开源了很多C++项目(protobuf,leveldb,glog,gtest)，是不错的学习对象。&lt;/p&gt;

&lt;h3&gt;推荐阅读：&lt;/h3&gt;

&lt;p&gt;[1] &lt;a href=&quot;http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml&quot;&gt;Google C++ Style Guide&lt;/a&gt;&lt;br/&gt;
[2] &lt;a href=&quot;https://github.com/brantyoung/zh-google-styleguide/&quot;&gt;Google C++编程风格指南&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;关于C++中的流：&lt;br/&gt;
[3] &lt;a href=&quot;http://www.cppblog.com/converse/archive/2010/07/06/119427.html&quot;&gt;C++的流设计很糟糕&lt;/a&gt;&lt;br/&gt;
[4] &lt;a href=&quot;http://blog.csdn.net/solstice/article/details/6612179&quot;&gt;C++ 工程实践(7)：iostream 的用途与局限&lt;/a&gt;，陈硕&lt;/p&gt;

&lt;p&gt;关于C++中的错误处理：&lt;br/&gt;
[5] &lt;a href=&quot;http://www.cppblog.com/converse/archive/2010/05/29/116689.html&quot;&gt;解读google C++ code style谈对C++的理解&lt;/a&gt;&lt;br/&gt;
[6] &lt;a href=&quot;http://blog.csdn.net/pongba/article/details/1815742&quot;&gt;错误处理(Error-Handling)：为何、何时、如何&lt;/a&gt;，刘未鹏&lt;br/&gt;
[7] &lt;a href=&quot;http://blog.jobbole.com/54699/&quot;&gt;C++的另一种错误处理策略&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;关于C++特性的裁减方案：&lt;br/&gt;
[8] &lt;a href=&quot;http://blog.csdn.net/myan/article/details/1920&quot;&gt;编程语言的层次观点——兼谈C++的剪裁方案&lt;/a&gt;，孟岩&lt;br/&gt;
[9] &lt;a href=&quot;http://blog.csdn.net/myan/article/details/1778843&quot;&gt;用C设计，用C++编码&lt;/a&gt;，孟岩&lt;/p&gt;

&lt;p&gt;关于C++11新特性的运用：&lt;br/&gt;
[10] &lt;a href=&quot;http://mindhacks.cn/2012/08/27/modern-cpp-practices/&quot;&gt;C++11（及现代C++风格）和快速迭代式开发&lt;/a&gt;，刘未鹏&lt;br/&gt;
[11] &lt;a href=&quot;http://herbsutter.com/elements-of-modern-c-style/&quot;&gt;Elements of Modern C++ Style&lt;/a&gt;&lt;br/&gt;
[12] &lt;a href=&quot;http://blog.csdn.net/myan/article/details/5877305&quot;&gt;C++0X的三件好东西（零）&lt;/a&gt;，孟岩&lt;br/&gt;
[13] &lt;a href=&quot;http://coolshell.cn/articles/5265.html&quot;&gt;C++11 中值得关注的几大变化（详解）&lt;/a&gt;，陈皓&lt;/p&gt;
</description>
                <link>/2014-01/google-cpp-style-guide/</link>
                <guid>/2014-01/google-cpp-style-guide</guid>
                <pubDate>Liquid error: undefined method `xmlschema' for "2014-01-28 07:45":String</pubDate>
        </item>

        <item>
                <title>如何在C/C++中调用Shell脚本</title>
                <description>&lt;h3&gt;缘起&lt;/h3&gt;

&lt;p&gt;在Linux平台下开发程序时，经常要处理一些锁碎的事情，比如删除某个目录下符合某种特征的文件，安装程序到某个目录下，打包备份一个程序，这些在Linux中很容易用shell来处理。在开发后台程序时，也经常要处理程序的安装、升级、备份，通常这些功能用shell脚本实现。所以不可避免的，要在程序中调用shell命令或shell脚本。之前考虑过这个问题，但没有深究。最近在维护一个项目时，要在C++程序中调用shell脚本来实现程序的升级和备份，所以花时间研究了一下，遂成本文。&lt;/p&gt;

&lt;!--more--&gt;


&lt;h3&gt;方法一：使用system函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int system(const char *string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;system()&lt;/code&gt;会调用&lt;code&gt;fork()&lt;/code&gt;产生子进程，由子进程来调用&lt;code&gt;/bin/sh-c string&lt;/code&gt;来执行参数string字符串所代表的命令，此命令执行完后随即返回原调用的进程。&lt;/p&gt;

&lt;p&gt;返回值：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;=-1:出现错误&lt;/li&gt;
&lt;li&gt;=0:调用成功但是没有出现子进程&lt;/li&gt;
&lt;li&gt;&gt;0:成功退出的子进程的id&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如果&lt;code&gt;system()&lt;/code&gt;在调用/bin/sh时失败则返回127，其他失败原因返回-1。若参数string为空指针(NULL)，则返回非零值。如果&lt;code&gt;system()&lt;/code&gt;调用成功则最后会返回执行shell命令后的返回值，但是此返回值也有可能为&lt;code&gt;system()&lt;/code&gt;调用/bin/sh失败所返回的127，因此最好能再检查errno来确认执行成功。&lt;/p&gt;

&lt;p&gt;根据&lt;code&gt;system()&lt;/code&gt;的返回值来判断shell脚本是否执行成功是一件比较繁琐的事情(参见这两篇文章：&lt;a href=&quot;http://blog.csdn.net/yangruibao/article/details/7255787&quot;&gt;博文一&lt;/a&gt;，&lt;a href=&quot;http://blog.csdn.net/ddkxddkx/article/details/7019408&quot;&gt;博文二&lt;/a&gt;)，且无法取得shell脚本的返回值。所以通常只是用&lt;code&gt;system()&lt;/code&gt;来调用一个shell命令，或较短的shell脚本。&lt;/p&gt;

&lt;h3&gt;方法二：使用popen函数，创建管道来连接两个程序的输入输出&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
FILE* popen ( const char *command , const char *type );
int pclose ( FILE *stream );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;popen()&lt;/code&gt;会调用&lt;code&gt;fork()&lt;/code&gt;产生子进程，然后从子进程中调用&lt;code&gt;/bin/sh -c&lt;/code&gt;来执行参数command的指令。参数type可使用r代表读取，w代表写入。依照mode值，&lt;code&gt;popen()&lt;/code&gt;会建立管道连接到子进程的标准输出流或标准输入流，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出流或是写入到子进程的标准输入流中。此外，所有使用文件指针(FILE*)操作的函数也都可以使用，除了&lt;code&gt;fclose()&lt;/code&gt;以外。&lt;/p&gt;

&lt;p&gt;具体来说：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;popen()&lt;/code&gt;函数通过创建一个管道，调用&lt;code&gt;fork()&lt;/code&gt;产生一个子进程，执行一个shell以运行命令来开启一个进程。这个进程必须由&lt;code&gt;pclose()&lt;/code&gt;函数关闭，而不是&lt;code&gt;fclose()&lt;/code&gt;函数。&lt;code&gt;pclose()&lt;/code&gt;函数关闭标准I/O流，等待命令执行结束，然后返回shell的终止状态。如果shell不能被执行，则&lt;code&gt;pclose()&lt;/code&gt;返回的终止状态与shell已执行exit一样。&lt;/p&gt;

&lt;p&gt;type参数只能是读或者写中的一种，得到的返回值（标准I/O流）也具有和type相应的只读或只写类型。如果type是&quot;r&quot;，则文件指针连接到command的标准输出；如果type是&quot;w&quot;，则文件指针连接到command的标准输入。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;popen()&lt;/code&gt;的返回值是个标准I/O流，必须由&lt;code&gt;pclose&lt;/code&gt;来终止。前面提到这个流是单向的，所以向这个流写内容相当于写入该命令的标准输入；与之相反的，从流中读数据相当于读取命令的标准输出。&lt;/p&gt;

&lt;p&gt;例：在~/myprogram/目录下有shell脚本&lt;code&gt;test.sh&lt;/code&gt;(打印HOME环境变量)，在C程序中调用shell脚本，并获取返回信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;sh test.sh&quot;&gt;#!bin/bash 
echo $HOME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在该目录下新建一个c文件&lt;code&gt;systemtest.c&lt;/code&gt;，内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;cpp systemtest.c&quot;&gt;#include&amp;lt;stdio.h&amp;gt;

int main()
{
    FILE *fp;
    char buffer[80];

    fp=popen(“~/myprogram/test.sh”,”r”);    //以读方式，fork产生一个子进程，执行shell命令
    fgets(buffer,sizeof(buffer),fp);       //读取shell脚本中输出(stdout)的值
    printf(“%s”,buffer);
    pclose(fp);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;bao@bao-Matrix:~/myprogram$vim systemtest.c
bao@bao-Matrix:~/myprogram$gcc systemtest.c -o systemtest
bao@bao-Matrix:~/myprogram$./systemtest
/home/bao
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;具体实现&lt;/h3&gt;

&lt;p&gt;根据程序开发需要，不仅需要执行shell脚本，而且要从脚本获取返回值。这个返回值可以是数值，也可以是字符串，或者任何标识脚本是否执行成功的值。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;ExecuteShell()&lt;/code&gt;传入脚本的路径及参数。在&lt;code&gt;ExecuteShell()&lt;/code&gt;函数中，调用&lt;code&gt;popen()&lt;/code&gt;执行shell脚本，通过fgets获取执行结果。执行结果中，1代表shell脚本执行成功，否则执行失败。（为什么不使用0作为成功判断，原因在于shell脚本发生任何不可控的错误时，stderr返回值都为0）&lt;/li&gt;
&lt;li&gt;在shell脚本中，输出结果用&lt;code&gt;echo/printf&lt;/code&gt;输出来(echo 1表示执行成功。如果执行过程中失败，则将错误信息重定向到日志文件)。echo输出的，会通过管道，传出到stdout。因为&lt;code&gt;popen()&lt;/code&gt;是以读方式打开shell脚本的。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;其中，&lt;code&gt;ExecuteShell()&lt;/code&gt;可以如下实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;int ExecuteShell(LPCSTR pShellName, char *szFormat, ...)
{
    if(pShellName == NULL)
    {
        return SHELL_RET_FAIL;
    }

    char szParam[256] = {0};
    char szCommand[256*2] = {0};
    char szResult[256] = {0};
    FILE* fp = NULL;
    int dwRet = 0;

    va_list pvList;
    va_start(pvList, szFormat); 
    const u32 actLen = vsprintf(szParam, szFormat, pvList);   //把所有参数都存入szParam字符串中
    if((actLen &amp;lt;= 0) || (actLen &amp;gt;= sizeof(szParam)))
    {   
        return SHELL_RET_FAIL;
    }
    va_end(pvList);

    sprintf(szCommand, &quot;%s %s&quot;, pShellName, szParam);     //取得执行shell脚本的命令szCommand
    fp = popen(szCommand, &quot;r&quot;);         //以读方式，fork产生一个子进程，执行shell命令
    if(fp == NULL)
    {
        return SHELL_RET_FAIL;
    }

    fgets(szResult,sizeof(szResult),fp);                  //读取shell脚本中输出(stdout)的值，即用echo输出的东西。
    pclose(fp);

    dwRet = atol(szResult);      //如果输出不为1，则说明执行失败！
    if( dwRet != 1 )
    {
        return SHELL_RET_FAIL;      
    }

    return SHELL_RET_OK;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在代码中，无论失败还是成功，使用“echo”命令返回执行结果。由于&lt;code&gt;popen()&lt;/code&gt;管道的存在，本来应该在标准输出显示的echo值被重定向到C/C++程序中。&lt;/li&gt;
&lt;li&gt;脚本执行成功，根据约定，返回数值“1”作为执行结果。&lt;/li&gt;
&lt;li&gt;程序过程中，如果发现任何错误，统一重定向到日志文件，并且echo输出到stdout。&lt;/li&gt;
&lt;li&gt;脚本中使用重定向的方法，把标准输出和标准错误全部重定向到“/dev/null”。由业务判断操作成功与否，返回错误值。如下：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;sh&quot;&gt;tar tvf $UPDATE_FILE | grep &quot;tvm/tvm&quot; &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的可以看一下这两个示例代码，&lt;a href=&quot;https://github.com/baozh/code-snippets/blob/master/ExecuteShell.cpp&quot;&gt;代码1&lt;/a&gt;，&lt;a href=&quot;https://github.com/baozh/code-snippets/blob/master/upgrade.sh&quot;&gt;代码2&lt;/a&gt;。&lt;/p&gt;
</description>
                <link>/2013-11/how-to-call-shell-script-in-c-plus-plus-program/</link>
                <guid>/2013-11/how-to-call-shell-script-in-c-plus-plus-program</guid>
                <pubDate>Liquid error: undefined method `xmlschema' for "2013-11-10 15:21":String</pubDate>
        </item>

        <item>
                <title>编辑器小结：VC 与 vim对比</title>
                <description>&lt;p&gt;俗话说“工欲善其事，必先利其器”，编程也是一样。找到一个合适的编程工具，可以大大提高程序员的生产效率。对编程来说，常用的工具有：编辑器、编译器、调试器、工程构建工具（类似make,CMake）、版本控制工具。其中编辑器是程序员中最常用的工具，每天接触，如果能找一个合适的编辑工具，可大大提高编程的效率。&lt;/p&gt;

&lt;!--more--&gt;


&lt;p&gt;之前一直在Linux平台上工作，喜欢Linux上的工具和文化。最近正式工作，接触到了生产环境下的产品开始，让我对linux工具有了一些自己的理解。现在公司编程使用编辑器vc6(就是老掉牙的visual C++ 6.0)，编辑完之后，用ssh登录到Linux主机，将自己的文件mount到linux上，进行编译、调试。之前我不太理解这种开发方式，我总认为Linux上的工具是很好的(至少要比大部分windows上的工具设计地简洁和高效)，直接在Linux上用vim或emacs编辑代码，再在本机上编译调试就行了，很方便，何必为了使用一个VC6编辑器，切换到windows上工作呢？最近正好看到王垠的&lt;a href=&quot;http://www.yinwang.org/blog-cn/2013/04/20/editor-ide/&quot;&gt;一篇好文&lt;/a&gt;，我也顺便谈一下对编辑器（具体来说，是程序的编辑器）的一些浅见。&lt;/p&gt;

&lt;h3&gt;编程文化不同&lt;/h3&gt;

&lt;p&gt;Unix文化中有一条著名的原则,KISS,keep it simple,stupid! 只做一件事情，但要把这件事情做到极致。使得在设计各个工具时尽量简单、简洁，向外提供接口，尽量保持其可扩展。所以在Linux上有各种各样的小工具，各个小工具都开放出接口，可以让别的工具调用。这样工具串工具，多个工具组合起来就能完成强大的功能。而Windows的哲学正好相反，各个工具之间是封闭的，互相难以组合。要保持良好的用户体验，一个工具要提供所有东西。Windows强调的是对用户友好，让用户可以快速学会这个工具。所以每个程序都要提供图形界面，且功能设计、界面布局尽量直观易用。而Linux强调的是功能强大，它把每个使用者都当成领域内的专家，把所有东西（包括程序内部的执行细节）都展现给用户，用户可以将其与其它工具组装整合，也可以修改配制（甚至修改源码、编译源码），将其定制成更符合自己使用习惯的工具。&lt;/p&gt;

&lt;h3&gt;IDE比Linux上整合的各种小工具强吗？&lt;/h3&gt;

&lt;p&gt;毫无疑问，Linux有各种各样功能强大的工具，将其组装起来，肯定比IDE强大多倍。Linux上有编辑器有vim,emacs,编译器有gcc,汇编器as,链接器ld,调试器gdb,ddd，构建工具make,CMake...而Windows把这些东西整合到了一块，叫Visual Studio。老实说，VS挺不错的，对程序员很友好，也有很多实用的功能。但如果单个组件与linux对应的最好工具相比，还有一些差距。比如，vim可以写文本，写email，写c++, python，lua,shell，自己想编辑什么，就加装类似的插件、定制快捷键。GCC可以用各种不同的编译选项，控制生成机器码的每个步骤。而gdb完全是纯命令行，可以看到很多程序内部的执行细节，比较底层的数据布局。还有一些汇编器as,链接器ld(在linux上是由OS提供了)之类，比较底层了，如果感觉用得不爽，可以自己修改一下，或者，自己写一个，编译时再替换原来的工具。IDE的优势是开发效率。开发速度快，写完代码直接点一个按钮就可以编译构建了，而linux上比较麻烦，要先编译一下，如果有错误，还要再调出gdb一个一个调试。感觉查错差不多了，再make一下。而unix上工具的优势是功能强大且容易组合。它比较适合开发那种比较底层的系统软件，可以让程序员掌握编程的每个执行细节。&lt;/p&gt;

&lt;h3&gt;VC的优势、Vim的优势&lt;/h3&gt;

&lt;p&gt;在写C++代码时，有时会思考vc和vim哪个更好用一些。得到的结论是vc更好用一些。在工作环境中，我把VC加装了各种插件，定制了快捷键，写了几个code snippet，写起代码来各种顺溜。也许没有了记忆负担，写程序时可以更好的专注思考编码，感觉很舒服。老实说，在写c++代码方面，vim肯定没有vc好用。vim当初设计时是考虑把它做成编辑所有文本（不仅仅是程序）的工具，所以没考虑对写程序做特殊的优化。而vc不是通用的文本编辑器，只能用来编辑程序，所以可以更好地理解程序。比如，在写代码时，经常会用来智能补全、跳转到定义处之类功能，vim加个ctags,OmiCppComplete插件也都能实现，但是实现的方式是比较笨拙。它是先对文本打标记，再用正则表达式进行匹配，有时候跳转时会经常出错，而且配置非常麻烦。而vc会真正分析程序的语义，它们的跳转和补全通常是比较精确的。还有一些功能是只有理解了程序的语义才能实现，比如补全时设置成最近几次的记录，把程序中的几行代码挑出来将其自动作为一个类的成员函数，这些功能vim很难实现。vim的优势是高度可定制，且移动速度快。vim可以在行内行间移动，可以在程序块中移动，可以在整个文件、屏幕移动，也可以根据搜索结果移动，如果把这些快捷键用熟了，编程时不需要碰鼠标。还有一个好处是，vim将对文本的各种操作都映射成了快捷键组合，比如复制用yy，删除用x,dd,dw，粘贴用p，撤销用u，而且这些组合键是可以定制的。&lt;/p&gt;

&lt;h3&gt;我的选择&lt;/h3&gt;

&lt;p&gt;现在要更加客观看待一下windows上的工具，有些工具是挺好用的，比如，VC相对于Vim,wireshark相对于tcpdump，photoshop相对于GIMP。我现在写c++代码用vc6(windows上编程时)，Linux上用eclipse(加个c/c++插件，和vi插件)，有时编辑纯文本也会用用vim和scriber。写python用spyder，写shell用kate。它们都是IDE，挺好，我觉得最适合我的方式是IDE+vi，就在各种开发工具加装vi的插件，这样既可以利用IDE的便利性，又可以利用vi的快速移动和命令操作。&lt;/p&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;要理解windows上与Linux上工具的差异，就必须理解Linux与Windows上不同的编程文化，下面有一些不错的资料：&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&quot;http://book.douban.com/subject/1467587/&quot;&gt;《unix编程艺术》&lt;/a&gt;，Eric S. Raymond&lt;/p&gt;

&lt;p&gt;这是一部最能反映Unix/Linux文化的著作，由unix的几个作者和开源大师Eric Raymond所著。提出了影响深远的unix哲学：KISS。&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&quot;http://www.cnbeta.com/articles/76147.htm&quot;&gt;《完全用Linux工作》&lt;/a&gt;，王垠&lt;/p&gt;

&lt;p&gt;3.&lt;a href=&quot;http://blog.sina.com.cn/s/blog_5d90e82f0101ip7f.html&quot;&gt;《谈 Linux，Windows 和 Mac》&lt;/a&gt;, 王垠&lt;/p&gt;

&lt;p&gt;王垠最近谈论linux,windows,mac的文章，显然没有以前那么偏激了。&lt;/p&gt;

&lt;p&gt;4.&lt;a href=&quot;http://blog.youxu.info/2013/03/03/unix-haters-2/&quot;&gt;《编程珠玑番外篇之番外篇-N 答 UNIX 痛恨者王垠》&lt;/a&gt;, 徐宥&lt;/p&gt;

&lt;p&gt;Google大牛徐宥对王垠文章的一些评论。&lt;/p&gt;

&lt;p&gt;5.&lt;a href=&quot;http://www.yinwang.org/blog-cn/2013/04/20/editor-ide/&quot;&gt;《编辑器与IDE》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6.&lt;a href=&quot;http://www.kuqin.com/developtool/20111130/315614.html&quot;&gt;《VIM之魅（上）》&lt;/a&gt;, &lt;a href=&quot;http://www.kuqin.com/developtool/20111213/316169.html&quot;&gt;《VIM之魅（下）》&lt;/a&gt;，郑晖&lt;/p&gt;

&lt;p&gt;这篇文章完整阐述了vim的设计哲学。&lt;/p&gt;

&lt;p&gt;7.&lt;a href=&quot;http://blog.csdn.net/wooin/article/details/1858917&quot;&gt;《手把手教你把Vim改装成一个IDE编程环境》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一篇教程，教你一步一步将vim和各种小插件整合成一个强大的IDE。&lt;/p&gt;
</description>
                <link>/2013-09/editor-summary-vc-vs-vim/</link>
                <guid>/2013-09/editor-summary-vc-vs-vim</guid>
                <pubDate>Liquid error: undefined method `xmlschema' for "2013-09-20 05:37":String</pubDate>
        </item>

        <item>
                <title>最近的生活</title>
                <description>&lt;p&gt;好久没有写点什么，今天刚好有空，想记录一下现在的生活。&lt;/p&gt;

&lt;h3&gt;回忆&lt;/h3&gt;

&lt;p&gt;记得刚辞职考研的时候，一位周围的同事和我说，“你会失败的，很多事情没你想得那么好。”当时挺年轻气盛的，我不相信，顶着压力，自己跑到我的本科学校准备考研。那一年的考研生活很辛苦，我的记忆很深刻。那时身边就带了5000多块钱，在学校旁边租了120块的房子，平时省吃俭用，就为了考上研究生。考研的生活很枯燥，很累，太孤单了，我主动认识了三个同为辞职考研的伙伴，大家平时复习时互相鼓劲，互相督促努力。最后的考研结果不太好，两个没考上，我和另一个都没有如愿考上心仪的学校，都调剂了。不过，当时我只有一个简单的信念：我只要有书念就行了，我知道自己想做什么，想学什么。&lt;/p&gt;

&lt;!--more--&gt;


&lt;p&gt;来到了新的大学，我很兴奋，终于可以读书了，可以学习自己想学的东西。我在心里描绘了一份蓝图，规划了我的读研生活，要看什么书，要做什么，要学什么。可惜在学校呆了几个月，现实给我泼了一盆冷水，现实和我想象中的研究生生活一点都不一样。有太多拘束了，导师太严，要发论文，不能出去实习，平时要帮导师干活，学自己知识的时间特别少。刚开始很失落，后来也认清现实了。很多事情我无力改变，只能尽力改变自己能改变的部分。我调整了一下我的学习计划，每个学期就那样学下去。三年读研生活还算过得比较充足，学到了很多专业知识，在交际感情方面也成长了不少。&lt;/p&gt;

&lt;p&gt;回想我的读研生活，有一些小tip是我的经验教训，我犯过的错误，我会记住的：&lt;/p&gt;

&lt;p&gt;Tip 1：生活并不是那么容易规划的，理想很丰满，现实很骨感。很多事情变化得太快了，很难规划。所以我不会给自己制定什么三年五年的规划，最多制定一年或半年的计划，让变化调整在可以控制的范围内。&lt;/p&gt;

&lt;p&gt;Tip 2：读研并不是必须的，也许工作中能学到更多的东西。
想清楚自己要做什么。如果自己适合做工程，那就早点去工业界，不要去读研浪费时间。&lt;/p&gt;

&lt;p&gt;Tip 3：看书很重要，但是实践更重要。
少就是多，多就是少。只有实践了才能把知识学精，虽然比较耗时间，但是理解会深刻。每个人的时间就那么多，这块学得多了，别的知识就没时间学了。以前我总是很贪心，想学很多东西，但是学得都不够深入。以后我会注意：只学一样东西，但要把那块知识学得足够深入。&lt;/p&gt;

&lt;h3&gt;工作&lt;/h3&gt;

&lt;p&gt;来到上海，是我的一个不小意外。之前一直想去北京，向往北京，可惜毕业前没有应聘到北京的工作，阴差阳错来到了上海。虽然有些失落，但还算挺满意的。现在工作的内容就是我的专业，是我喜欢做的东西，可以认识很多不同背景的朋友，也可以学到很多东西。&lt;/p&gt;

&lt;p&gt;上海是一个开放的城市，很繁荣，服务业的水平很高。有很多不错的公司，厉害的人很多，所以竞争很激烈。平时工作节奏很快，很忙碌。我开始不太适应的，现在习惯了一些。我现在的工作是做Linux服务器端开发，涉及到很多linux网络通信方面的知识，我很喜欢钻研这方面的知识。&lt;/p&gt;

&lt;p&gt;平时工作很累，下班一回到家，我就倒在床上睡着了。醒来之后就洗刷一下，休息一会，继续睡觉。睡到凌晨4:50左右起床，学习、洗刷、煮粥、吃饭。学到8:30左右去公司上班。周末的时候会学习，也可以联系几个朋友出去逛逛。现在刚工作，很多东西都不会，所以周末的时候我基本不会休息，加紧时间充电学习。&lt;/p&gt;

&lt;h3&gt;考驾照&lt;/h3&gt;

&lt;p&gt;学车的这段经历很难忘，我的记忆很深刻，因为自己手脚太笨拙了，被骂了好多次。&lt;/p&gt;

&lt;p&gt;今年上半年递交毕业论文后，有几个月的空闲时间，我就报名学车了。刚开始第一次上车的时候，好几次起步没起来，还撞到路牙上，被教练骂得太多了。我怕被教练骂，想平时花钱租个车请人教我练习一下。可是找了半天，车租不下来。后来打电话向我室友倾诉，室友安慰了好多，叫我“学着脸皮厚一点，被骂没什么大不了的。”慢慢得，学车学了一段时间，也习惯了被骂，不再恐惧了，开车水平有了一点点的增长。过了一个月，要考科目二，紧张，有压力。我很想一次性通过的，因为我很快就要去上海工作了。可能是因为压力太大了，考科目二第一次坡道起步熄火了，第二次成功了，但是回炉倒车入库失手了，真是悲摧。当时感觉科目二真是一座迈不过去的大山，好像很难通过似的。有点纠结，恐惧，想放弃了。。。&lt;/p&gt;

&lt;p&gt;后来去上海了，安顿了一下。接到了爸爸的电话，叫我学车付了钱一定要拿到驾照，不要中途放弃。后来顶着试一试的心理，又回到的镇江，准备科目二补考。这次心情轻松了好多，不会有那么大压力，反正考不过就考不过。练习了两天，终于通过了，很兴奋。考完了又马上回上海上班了。过个半个月，考科目三。我请了两天假，把科目三通过了。现在科目四还没考，比较简单，再过半个月再考吧。&lt;/p&gt;

&lt;p&gt;回顾我的学车经历，真是一段很难忘的经历，让我学到了好多。最重要的是让我的脸皮变厚了，现在不管别人怎么骂我，我就笑笑，不会那么在意了。&lt;/p&gt;

&lt;h3&gt;我是一只IT小小鸟，痛并快乐着&lt;/h3&gt;

&lt;p&gt;记得了考研时候看过这样一本书：&lt;a href=&quot;http://book.douban.com/subject/4006425/&quot;&gt;《我是一只IT小小鸟》&lt;/a&gt;，它记录了一些同龄IT人的奋斗经历，它们吃的苦，它们的学习方法，它们所经历的那些事。其中有一段话我挺喜欢的：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;有时候觉得自己糊里糊涂，有时候又觉得活得挺明白，而我的梦想是什么？我梦想着世界和平，人人都能受到良好的教育，世界大团结；我梦想着有幸福的家庭，和赖以生活的职业……&lt;/p&gt;

&lt;p&gt;梦想和现实的差距，就是我们生活的意义。因为有差距，我们才一直在积累、在努力。因为有美丽的梦，我们活着才有希冀。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;谢谢这本书，我会继续努力。&lt;/p&gt;
</description>
                <link>/2013-08/recent-life/</link>
                <guid>/2013-08/recent-life</guid>
                <pubDate>Liquid error: undefined method `xmlschema' for "2013-08-04 09:03":String</pubDate>
        </item>

        <item>
                <title>A Note of Learning Markdown</title>
                <description>&lt;p&gt;This is my note of learning markdown, also a digest from &lt;a href=&quot;http://daringfireball.net/projects/markdown/syntax&quot;&gt;this paper&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;INTRODUCTION&lt;/h3&gt;

&lt;p&gt;Markdown is a text-to-HTML conversion tool for web writers. Markdown allows you to write using an easy-to-read, easy-to-write plain text format, then convert it to structurally valid XHTML (or HTML).&lt;/p&gt;

&lt;p&gt;Thus, “Markdown” is two things: (1) a plain text formatting syntax; and (2) a software tool, written in Perl, that converts the plain text formatting to HTML. See the Syntax page for details pertaining to Markdown’s formatting syntax.&lt;/p&gt;

&lt;!--more--&gt;


&lt;p&gt;The overriding design goal for Markdown’s formatting syntax is to make it as readable as possible. The idea is that a Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. While Markdown’s syntax has been influenced by several existing text-to-HTML filters, the single biggest source of inspiration for Markdown’s syntax is the format of plain text email.&lt;/p&gt;

&lt;p&gt;The best way to get a feel for Markdown’s formatting syntax is simply to &lt;em&gt;look at a Markdown-formatted document&lt;/em&gt;.&lt;/p&gt;

&lt;h3&gt;MARKDOWN SYNTEX DETAIL&lt;/h3&gt;

&lt;h4&gt;PHILOSOPYH&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Markdown is intended to be as easy-to-read and easy-to-write as is feasible.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Readability&lt;/em&gt;, however, is emphasized above all else. A Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions. While Markdown’s syntax has been influenced by several existing text-to-HTML filters — including Setext, atx, Textile, reStructuredText,Grutatext, and EtText — the single biggest source of inspiration for Markdown’s syntax is the format of plain text email.&lt;/p&gt;

&lt;p&gt;To this end, &lt;em&gt;Markdown’s syntax is comprised entirely of punctuation characters, which punctuation characters have been carefully chosen so as to look like what they mean.&lt;/em&gt; E.g., asterisks around a word actually look like *emphasis*. Markdown lists look like, well, lists. Even blockquotes look like quoted passages of text, assuming you’ve ever used email.&lt;/p&gt;

&lt;h4&gt;SYNTEX DETAIL&lt;/h4&gt;

&lt;p&gt;1. headers 标题&lt;/p&gt;

&lt;p&gt;the number of opening hashes determines the header level.&lt;/p&gt;

&lt;p&gt;using 1-6 hash characters at the start of the line, corresponding to header level 1-6.&lt;/p&gt;

&lt;h1&gt;This is an H1.&lt;/h1&gt;

&lt;h2&gt;This is an H2.&lt;/h2&gt;

&lt;h3&gt;This is an H3.&lt;/h3&gt;

&lt;h4&gt;This is an H4.&lt;/h4&gt;

&lt;h6&gt;This is an H6.&lt;/h6&gt;

&lt;p&gt;2. blockquotes 块引用&lt;/p&gt;

&lt;p&gt;put a &gt; (right angle brackets) before every line you quoted.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Email-style angle brackets
are used for blockquotes.&lt;/p&gt;

&lt;p&gt;Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;blockquotes can be nested by adding additional level of &gt;.&lt;/p&gt;

&lt;p&gt;blockquotes can be contain other MARKDOWN elements, including headers,lists,and code blocks.&lt;/p&gt;

&lt;p&gt;3. lists 列表&lt;/p&gt;

&lt;p&gt;support ordered(numbered) and unordered(bulleded) lists.&lt;/p&gt;

&lt;p&gt;(1) unordered list:&lt;/p&gt;

&lt;p&gt;adding * or - in front of the line.&lt;/p&gt;

&lt;p&gt;- red&lt;/p&gt;

&lt;p&gt;- green&lt;/p&gt;

&lt;p&gt;- blue&lt;/p&gt;

&lt;p&gt;or,&lt;/p&gt;

&lt;p&gt;* red&lt;/p&gt;

&lt;p&gt;* green&lt;/p&gt;

&lt;p&gt;* blue&lt;/p&gt;

&lt;p&gt;this have some points for attention.&lt;/p&gt;

&lt;p&gt;1) List markers typically start at the left margin, but may be indented by up to three spaces.&lt;/p&gt;

&lt;p&gt;2) List items may consist of multiple paragraphs. Each subsequent paragraph in a list item must be indented by either 4 spaces or one Tab.&lt;/p&gt;

&lt;p&gt;一个列表项的第一行要在“－”或“＊”或“数学.”后加空格（至多三个），其后此段落的行可以加空格（与第一行保持一致的缩进）。&lt;/p&gt;

&lt;p&gt;此列表项的下一个段落以4空格或1个Tab来缩进。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;This is a list item with two paragraphs.&lt;/p&gt;

&lt;p&gt; This is the second paragraph in the list item. You're
 only required to indent the first line.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Anther item in the same list.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;3) Put a blockquote within a list item, the blockquotes's &gt; delimiters need to be indeeted.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A list item with a blockquotes:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;This is a blockquote
inside a list item.&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;4) Put a code block within a list item, the code block needs to be indented &lt;em&gt;twice - 8 spaces or two Tabs&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A list item with a code block:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  return shell_exec(&quot;echo $input | $markdown_script&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;(2) ordered list:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;red&lt;/li&gt;
&lt;li&gt;Green&lt;/li&gt;
&lt;li&gt;Blue&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;note:&lt;/p&gt;

&lt;p&gt;A number-period-space sequence at the beginning of a line will trigger and ordered list. Sometimes, you can backslash-escape the period.&lt;/p&gt;

&lt;p&gt;1986. what a great season.&lt;/p&gt;

&lt;p&gt;=&gt; 1986\. what a great season.&lt;/p&gt;

&lt;p&gt;4. code blocks 代码段&lt;/p&gt;

&lt;p&gt;Simply indent every line of the code blocks by at least 4 spaces or 1 Tab.&lt;/p&gt;

&lt;p&gt;A code block continues until it reaches a line that is not indented(or the end of the artile).&lt;/p&gt;

&lt;p&gt;This is a normal paragraph:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is a code block.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5. horizontal rules  分隔线，水平线&lt;/p&gt;

&lt;p&gt;place three or more hyphens, asterisks.行中只有&quot;-&quot;或&quot;&lt;em&gt;&quot;，不能有其他字符。行中的&quot;&lt;/em&gt;&quot;或&quot;-&quot;之间可以加空格（也可以不加）。&lt;/p&gt;

&lt;p&gt;***&lt;/p&gt;

&lt;p&gt;-----------&lt;/p&gt;

&lt;p&gt;6. links 链接&lt;/p&gt;

&lt;p&gt;方法1：inline style:&lt;/p&gt;

&lt;p&gt;An [example](http://url.com/ &quot;an optional title&quot;)&lt;/p&gt;

&lt;p&gt;方法2：reference style:&lt;/p&gt;

&lt;p&gt;An [example][id]........&lt;/p&gt;

&lt;p&gt;.......&lt;/p&gt;

&lt;p&gt;[id]: http://example.com/ &quot;an optional title&quot;&lt;/p&gt;

&lt;p&gt;有时候链接文字比较短，这时可以省略id.&lt;/p&gt;

&lt;p&gt;[Google][]&lt;/p&gt;

&lt;p&gt;....&lt;/p&gt;

&lt;p&gt;[Google]: http://google.com/&lt;/p&gt;

&lt;p&gt;7. emphasis&lt;/p&gt;

&lt;p&gt;*single asterisk, italic*&lt;/p&gt;

&lt;p&gt;**double aterisk, bold**&lt;/p&gt;

&lt;p&gt;8. code span&lt;/p&gt;

&lt;p&gt;Unlike a preformatted code block, a code span indicates code within a normal paragraph.&lt;/p&gt;

&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;9. images   图片&lt;/p&gt;

&lt;p&gt;方法1: inline style:&lt;/p&gt;

&lt;p&gt;![alt text](/path/to/img.jpg &quot;optional title&quot;)&lt;/p&gt;

&lt;p&gt;方法2: reference style:&lt;/p&gt;

&lt;p&gt;![alt text][id]&lt;/p&gt;

&lt;p&gt;...&lt;/p&gt;

&lt;p&gt;[id]: /url/to/img.jpg &quot;optional title&quot;&lt;/p&gt;

&lt;p&gt;As of this writing, Markdown has no syntex for specifying the dimensions of an image; if this is important to you, you can simply use regular HTML &lt;img&gt; tags.&lt;/p&gt;

&lt;p&gt;10. automatic links&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://example/&quot;&gt;http://example/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&amp;#x6d;&amp;#x61;&amp;#x69;&amp;#108;&amp;#x74;&amp;#111;&amp;#x3a;&amp;#x61;&amp;#100;&amp;#100;&amp;#x72;&amp;#x65;&amp;#x73;&amp;#115;&amp;#x40;&amp;#101;&amp;#x78;&amp;#x61;&amp;#109;&amp;#112;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#x6f;&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#114;&amp;#x65;&amp;#x73;&amp;#x73;&amp;#64;&amp;#x65;&amp;#120;&amp;#97;&amp;#x6d;&amp;#x70;&amp;#x6c;&amp;#x65;&amp;#x2e;&amp;#99;&amp;#111;&amp;#x6d;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;11. backslash escapes 转义字符&lt;/p&gt;

&lt;p&gt;Markdown allows you to use backslash escapes to generate literal characters which would otherwise have special meaning in Markdown’s formatting syntax. For example, if you wanted to surround a word with literal asterisks (instead of an HTML &lt;em&gt; tag), you can use backslashes before the asterisks, like this:&lt;/p&gt;

&lt;p&gt;\*literal asterisks\*&lt;/p&gt;

&lt;p&gt;Markdown provides backslash escapes for the following characters:&lt;/p&gt;

&lt;p&gt;\   backslash&lt;/p&gt;

&lt;p&gt;`   backtick&lt;/p&gt;

&lt;p&gt;*   asterisk&lt;/p&gt;

&lt;p&gt;_   underscore&lt;/p&gt;

&lt;p&gt;{}  curly braces&lt;/p&gt;

&lt;p&gt;[]  square brackets&lt;/p&gt;

&lt;p&gt;()  parentheses&lt;/p&gt;

&lt;p&gt;#   hash mark&lt;/p&gt;

&lt;p&gt;+   plus sign&lt;/p&gt;

&lt;p&gt;-   minus sign (hyphen)&lt;/p&gt;

&lt;p&gt;.   dot&lt;/p&gt;

&lt;p&gt;!   exclamation mark&lt;/p&gt;
</description>
                <link>/2013-04/test/</link>
                <guid>/2013-04/test</guid>
                <pubDate>Liquid error: undefined method `xmlschema' for "2013-04-17 23:15":String</pubDate>
        </item>

        <item>
                <title>hello,world!</title>
                <description>&lt;p&gt;终于有自己的博客了，写第一篇博客，就像刚入门编程时一样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hello,world!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hello,My blog!&lt;/strong&gt;&lt;/p&gt;
</description>
                <link>/2013-04/hello/</link>
                <guid>/2013-04/hello</guid>
                <pubDate>Liquid error: undefined method `xmlschema' for "2013-04-16 17:47":String</pubDate>
        </item>


</channel>
</rss>
